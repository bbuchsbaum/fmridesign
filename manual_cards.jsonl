{"id":"manual#1","symbols":["fmridesign::event_model","fmridesign::sampling_frame","fmridesign::hrf","fmridesign::design_matrix"],"q":"How do I create a basic event model from onset times and conditions?","a":"Use event_model() with a formula specifying onset ~ hrf(condition). Define the temporal structure with sampling_frame(), pass your event data frame with onset times and condition labels, and specify the block column. Extract the resulting design matrix with design_matrix().","recipe":"sframe <- fmridesign::sampling_frame(blocklens = 150, TR = 2)\nevents <- data.frame(\n  onset = c(10, 30, 50, 70, 90),\n  cond = factor(c(\"A\", \"B\", \"A\", \"B\", \"A\")),\n  block = factor(rep(1, 5))\n)\nemod <- fmridesign::event_model(\n  onset ~ hrf(cond),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)\nX <- fmridesign::design_matrix(emod)","tags":["event-model","formula","quickstart"]}
{"id":"manual#2","symbols":["fmridesign::sampling_frame"],"q":"How do I define a multi-run sampling frame for an fMRI experiment?","a":"Use sampling_frame() with a vector of scan counts per run and the repetition time (TR). Each element of blocklens specifies the number of scans in that run. The resulting object defines the temporal grid used by event and baseline models.","recipe":"# 3 runs: 200, 180, 200 scans each, TR = 2 seconds\nsframe <- fmridesign::sampling_frame(\n  blocklens = c(200, 180, 200),\n  TR = 2\n)\nprint(sframe)","tags":["sampling-frame","multi-run","setup"]}
{"id":"manual#3","symbols":["fmridesign::baseline_model","fmridesign::design_matrix","fmridesign::sampling_frame"],"q":"How do I build a baseline model with polynomial drift correction?","a":"Use baseline_model() with basis = 'poly' and degree to control the polynomial order. Pass the same sampling_frame used for your event model. The baseline produces per-run drift regressors and intercepts. Extract the matrix with design_matrix() and cbind it with the event design matrix.","recipe":"sframe <- fmridesign::sampling_frame(blocklens = c(150, 150), TR = 2)\nbmod <- fmridesign::baseline_model(\n  basis = \"poly\", degree = 5, sframe = sframe\n)\nX_baseline <- fmridesign::design_matrix(bmod)\ndim(X_baseline)","tags":["baseline","drift","polynomial"]}
{"id":"manual#4","symbols":["fmridesign::event_model","fmridesign::baseline_model","fmridesign::design_matrix"],"q":"How do I combine event and baseline design matrices into a full GLM design?","a":"Build the event model with event_model() and the baseline model with baseline_model() using the same sampling_frame. Extract each design matrix with design_matrix(), then column-bind them with cbind() or dplyr::bind_cols(). The combined matrix is the full design for GLM fitting.","recipe":"# Assuming emod and bmod already created with same sframe\nX_task <- fmridesign::design_matrix(emod)\nX_base <- fmridesign::design_matrix(bmod)\nX_full <- cbind(X_task, X_base)\ndim(X_full)","tags":["design-matrix","glm","combine"]}
{"id":"manual#5","symbols":["fmridesign::event_model","fmridesign::hrf","fmridesign::pair_contrast","fmridesign::contrast_weights"],"q":"How do I define a pairwise contrast between two conditions?","a":"Use pair_contrast() inside the contrasts argument of hrf(). Specify two conditions with formula syntax (~ var == 'level') and a name. Extract weights with contrast_weights() on the event model. The resulting vector has +1 for the first condition and -1 for the second.","recipe":"emod <- fmridesign::event_model(\n  onset ~ hrf(cond,\n    contrasts = fmridesign::pair_contrast(\n      ~ cond == \"A\", ~ cond == \"B\",\n      name = \"A_vs_B\")),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)\ncw <- fmridesign::contrast_weights(emod)\nnames(cw)","tags":["contrast","pairwise","hypothesis"]}
{"id":"manual#6","symbols":["fmridesign::event_model","fmridesign::hrf"],"q":"How do I add a parametric modulator like reaction time to an event model?","a":"Include the continuous variable as a separate hrf() term in the formula. Center the modulator (e.g., with scale()) before modeling. The formula onset ~ hrf(condition) + hrf(RT) creates main-effect regressors for condition and a parametric modulator for RT, each convolved with the HRF.","recipe":"events$RT <- scale(events$RT_raw, center = TRUE, scale = FALSE)[,1]\nemod <- fmridesign::event_model(\n  onset ~ hrf(condition) + hrf(RT),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)","tags":["parametric","modulator","continuous"]}
{"id":"manual#7","symbols":["fmridesign::event_model","fmridesign::trialwise","fmridesign::design_matrix"],"q":"How do I create a trialwise model for beta-series correlation analysis?","a":"Use trialwise() in the event_model() formula instead of hrf(). This creates a separate regressor for every individual trial, producing a design matrix with one column per event. The resulting beta estimates can be used for representational similarity analysis or beta-series connectivity.","recipe":"emod_tw <- fmridesign::event_model(\n  onset ~ trialwise(),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)\nX_tw <- fmridesign::design_matrix(emod_tw)\nncol(X_tw)  # one column per trial","tags":["trialwise","beta-series","rsa"]}
{"id":"manual#8","symbols":["fmridesign::check_collinearity","fmridesign::design_matrix"],"q":"How do I check my design matrix for collinearity problems?","a":"Use check_collinearity() on the design matrix with a correlation threshold (e.g., 0.9). It returns a list with an 'ok' flag and a data frame of highly correlated column pairs. Address collinearity by adjusting event timing, removing redundant regressors, or orthogonalizing modulators.","recipe":"X <- fmridesign::design_matrix(emod)\ncc <- fmridesign::check_collinearity(X, threshold = 0.9)\nif (!cc$ok) {\n  print(cc$pairs)\n}","tags":["collinearity","diagnostics","quality"]}
{"id":"manual#9","symbols":["fmridesign::correlation_map","fmridesign::design_map"],"q":"How do I visualize the design matrix structure and regressor correlations?","a":"Use design_map() to plot a heatmap of the design matrix values (rows = scans, columns = regressors). Use correlation_map() to plot the pairwise correlation matrix between regressors. Both return ggplot objects that can be customized further.","recipe":"# Heatmap of design matrix values\nfmridesign::design_map(emod)\n\n# Correlation between regressors\nfmridesign::correlation_map(emod)","tags":["visualization","heatmap","correlation"]}
{"id":"manual#10","symbols":["fmridesign::baseline_model","fmridesign::sampling_frame"],"q":"How do I add motion parameters as nuisance regressors to a baseline model?","a":"Pass motion parameters via the nuisance_list argument of baseline_model(). Provide a list with one data frame per run, each containing the nuisance columns (e.g., 6 motion parameters). These are included as-is in the baseline design matrix without HRF convolution.","recipe":"nuis <- list(\n  run1 = data.frame(mx = rnorm(150), my = rnorm(150), mz = rnorm(150)),\n  run2 = data.frame(mx = rnorm(150), my = rnorm(150), mz = rnorm(150))\n)\nsframe <- fmridesign::sampling_frame(blocklens = c(150, 150), TR = 2)\nbmod <- fmridesign::baseline_model(\n  basis = \"poly\", degree = 3, sframe = sframe,\n  nuisance_list = nuis\n)","tags":["baseline","nuisance","motion"]}
{"id":"manual#11","symbols":["fmridesign::event_model","fmridesign::hrf"],"q":"How do I use a multi-basis HRF like SPMG3 or FIR in an event model?","a":"Specify the basis argument inside hrf(). Use basis = 'spmg3' for the SPM canonical plus temporal and dispersion derivatives (3 columns per condition), or basis = 'fir' with nbasis for a finite impulse response model. Multi-basis HRFs allow flexible response shape estimation.","recipe":"# SPM canonical + derivatives (3 basis functions)\nemod_spmg3 <- fmridesign::event_model(\n  onset ~ hrf(cond, basis = \"spmg3\"),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)\n\n# FIR model with 12 time bins\nemod_fir <- fmridesign::event_model(\n  onset ~ hrf(cond, basis = \"fir\", nbasis = 12),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)","tags":["hrf","multi-basis","fir","spmg3"]}
{"id":"manual#12","symbols":["fmridesign::event_model","fmridesign::hrf","fmridesign::contrast_set","fmridesign::oneway_contrast","fmridesign::interaction_contrast"],"q":"How do I test main effects and interactions in a factorial design?","a":"Pass multiple factors to a single hrf() call to model their interaction. Use contrast_set() to bundle oneway_contrast() for main effects and interaction_contrast() for the interaction. Extract weights with contrast_weights() and omnibus F-tests with Fcontrasts().","recipe":"emod <- fmridesign::event_model(\n  onset ~ hrf(A, B, contrasts = fmridesign::contrast_set(\n    fmridesign::oneway_contrast(~ A, name = \"main_A\"),\n    fmridesign::oneway_contrast(~ B, name = \"main_B\"),\n    fmridesign::interaction_contrast(~ A * B, name = \"AxB\")\n  )),\n  data = events, block = ~ block,\n  sampling_frame = sframe\n)","tags":["factorial","interaction","anova"]}
{"id":"manual#13","symbols":["fmridesign::validate_contrasts","fmridesign::design_matrix"],"q":"How do I validate that my contrasts are estimable given the design?","a":"Use validate_contrasts() on the event model or its design matrix. It checks that contrast vectors are well-formed, estimable, and reports the contrast type (t or F). Pass custom weight vectors via the weights argument, or omit it to validate all contrasts attached to the model.","recipe":"# Validate all attached contrasts\nres <- fmridesign::validate_contrasts(emod)\nprint(res)\n\n# Validate a custom contrast vector\nX <- fmridesign::design_matrix(emod)\ncustom_wt <- rep(0, ncol(X))\ncustom_wt[1] <- 1; custom_wt[2] <- -1\nfmridesign::validate_contrasts(X, weights = custom_wt)","tags":["contrast","validation","estimability"]}
{"id":"manual#14","symbols":["fmridesign::event_model","fmridesign::hrf","fmridesign::sampling_frame"],"q":"How do I model a block design with sustained stimulus durations?","a":"Pass event durations via the durations argument of event_model(). Each event gets a boxcar of the specified duration before HRF convolution. For block designs with alternating task/rest periods, set durations to the block length (e.g., 20 seconds).","recipe":"block_events <- data.frame(\n  onset = seq(0, 280, by = 40),\n  cond = factor(rep(c(\"task\", \"rest\"), length.out = 8)),\n  block = factor(rep(1, 8))\n)\nsframe <- fmridesign::sampling_frame(blocklens = 150, TR = 2)\nemod_block <- fmridesign::event_model(\n  onset ~ hrf(cond),\n  data = block_events, block = ~ block,\n  durations = rep(20, 8),\n  sampling_frame = sframe\n)","tags":["block-design","duration","boxcar"]}
{"id":"manual#15","symbols":["fmridesign::residualize","fmridesign::baseline_model","fmridesign::event_model"],"q":"How do I residualize data or a design matrix against the baseline model?","a":"Use residualize() to project out baseline effects from a matrix. Pass the baseline model and optionally an event model. This removes drift and nuisance variance, leaving only task-related signal. Useful for cleaning data before connectivity or multivariate analyses.","recipe":"bmod <- fmridesign::baseline_model(\n  basis = \"poly\", degree = 3, sframe = sframe\n)\n# Residualize the event design matrix against baseline\nX_task <- fmridesign::design_matrix(emod)\nX_clean <- fmridesign::residualize(bmod, X_task)","tags":["residualize","baseline","preprocessing"]}
