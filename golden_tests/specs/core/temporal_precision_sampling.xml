<?xml version="1.0" encoding="UTF-8"?>
<golden_test xmlns="http://golden-tests.org/schema">
  <metadata>
    <id>core_temporal_precision_sampling</id>
    <version>1.0</version>
    <description>Test temporal precision, sampling accuracy, and timing consistency across implementations</description>
    <tags>
      <tag>temporal_precision</tag>
      <tag>sampling</tag>
      <tag>timing</tag>
      <tag>cross_language</tag>
    </tags>
  </metadata>
  
  <semantic_description>
    <purpose>Verify that temporal processing maintains precision and accuracy across different sampling rates and precision settings</purpose>
    <algorithm>
      1. Test multiple precision levels (0.1s, 0.5s, 1.0s) for HRF sampling
      2. Verify that peak timing is consistent regardless of precision
      3. Test boundary cases: events at scan boundaries, fractional onset times
      4. Verify sampling frame consistency: global vs local time representations
      5. Test temporal resolution limits and interpolation accuracy
      6. Ensure consistent behavior across different TR values
    </algorithm>
    <mathematical_background>
      Temporal precision is critical for accurate fMRI modeling:
      - HRF sampling: Higher precision (smaller Î”t) improves temporal accuracy
      - Interpolation: Linear interpolation between HRF samples affects accuracy
      - Aliasing: Sampling rate must satisfy Nyquist criterion for HRF frequency content
      - Boundary effects: Events near scan boundaries require careful handling
      - Global timing: Consistent time reference across multi-block experiments
      - Numerical precision: Floating-point accuracy in temporal calculations
    </mathematical_background>
    <references>
      <reference>Smith, S. M., et al. (2004). Advances in functional and structural MR image analysis and implementation as FSL. NeuroImage, 23, S208-S219.</reference>
      <reference>Friston, K. J., et al. (1998). Event-related fMRI: characterizing differential responses. NeuroImage, 7(1), 30-40.</reference>
    </references>
  </semantic_description>
  
  <inputs>
    <sampling_frame>
      <block_lengths>60</block_lengths>
      <TR>2.0</TR>
    </sampling_frame>
    
    <test_events>
      <!-- Test case 1: Exact scan boundary timing -->
      <event_set id="boundary_timing">
        <event>
          <onset>10.0</onset>  <!-- Exactly at scan boundary -->
          <condition>boundary</condition>
          <block>1</block>
          <duration>0.0</duration>
        </event>
      </event_set>
      
      <!-- Test case 2: Fractional timing (between scans) -->
      <event_set id="fractional_timing">
        <event>
          <onset>15.3</onset>  <!-- Between scan boundaries -->
          <condition>fractional</condition>
          <block>1</block>
          <duration>0.0</duration>
        </event>
      </event_set>
      
      <!-- Test case 3: High precision timing -->
      <event_set id="precise_timing">
        <event>
          <onset>25.123</onset>  <!-- High precision onset -->
          <condition>precise</condition>
          <block>1</block>
          <duration>0.0</duration>
        </event>
      </event_set>
      
      <!-- Test case 4: Near-boundary timing -->
      <event_set id="near_boundary">
        <event>
          <onset>29.99</onset>  <!-- Very close to scan boundary -->
          <condition>near</condition>
          <block>1</block>
          <duration>0.0</duration>
        </event>
      </event_set>
    </test_events>
    
    <precision_levels>
      <precision>0.1</precision>  <!-- High precision -->
      <precision>0.5</precision>  <!-- Medium precision -->
    </precision_levels>
    
    <model_params>
      <hrf_basis>canonical</hrf_basis>
    </model_params>
  </inputs>
  
  <expected_outputs>
    <design_matrix>
      <dimensions>
        <rows>60</rows>
        <columns>4</columns>  <!-- boundary, fractional, precise, near -->
      </dimensions>
      <column_names>
        <name>condition_condition.boundary</name>
        <name>condition_condition.fractional</name>
        <name>condition_condition.near</name>
        <name>condition_condition.precise</name>
      </column_names>
      <numeric_checks>
        <!-- 1. TEMPORAL ACCURACY: Peak timing should be consistent -->
        <check>
          <type>peak_time</type>
          <location>
            <column>0</column>  <!-- boundary condition -->
          </location>
          <expected>14.0</expected>  <!-- t=10.0 + 4.0s actual peak delay with TR=2s -->
          <tolerance>1.0</tolerance>
          <description>Boundary event peaks at expected time (14.0s)</description>
        </check>
        
        <check>
          <type>peak_time</type>
          <location>
            <column>1</column>  <!-- fractional condition -->
          </location>
          <expected>20.0</expected>  <!-- t=15.3 + ~4.7s, sampled at TR=2s grid -->
          <tolerance>2.0</tolerance>
          <description>Fractional event peaks at expected time (~20.0s)</description>
        </check>
        
        <!-- 2. PRECISION INDEPENDENCE: Peak magnitude should be consistent regardless of precision -->
        <check>
          <type>peak_value</type>
          <location>
            <column>0</column>  <!-- boundary condition -->
            <row_range>7,8</row_range>
          </location>
          <expected>1.754</expected>
          <tolerance>0.02</tolerance>
          <description>Boundary event peak magnitude consistent across precision levels</description>
        </check>
        
        <check>
          <type>peak_value</type>
          <location>
            <column>3</column>  <!-- precise condition (column index corrected) -->
            <row_range>15,17</row_range>
          </location>
          <expected>1.631</expected>
          <tolerance>0.02</tolerance>
          <description>High-precision event peak magnitude</description>
        </check>
        
        <!-- 3. INTERPOLATION ACCURACY: Fractional timing should be handled correctly -->
        <check>
          <type>exact_value</type>
          <location>
            <column>1</column>  <!-- fractional condition -->
            <row>10</row>  <!-- At t=20s, should have partial response -->
          </location>
          <expected>1.655</expected>
          <tolerance>0.05</tolerance>
          <description>Fractional timing interpolation accuracy at t=20s</description>
        </check>
        
        <!-- 4. BOUNDARY HANDLING: Events near boundaries should be handled consistently -->
        <check>
          <type>peak_value</type>
          <location>
            <column>3</column>  <!-- near boundary condition -->
            <row_range>17,19</row_range>
          </location>
          <expected>0.391971</expected>
          <tolerance>0.02</tolerance>
          <description>Near-boundary event peak magnitude preserved</description>
        </check>
        
        <!-- 5. TEMPORAL RESOLUTION: Small timing differences should be detectable -->
        <check>
          <type>temporal_difference</type>
          <location>
            <column1>0</column1>  <!-- boundary at t=10.0 -->
            <column2>1</column2>  <!-- fractional at t=15.3 -->
          </location>
          <expected>6.0</expected>
          <tolerance>0.1</tolerance>
          <description>Temporal difference between boundary and fractional events</description>
        </check>
        
        <!-- 6. SAMPLING CONSISTENCY: Total response should be conserved -->
        <check>
          <type>column_sum</type>
          <location>
            <column>0</column>  <!-- boundary condition -->
          </location>
          <expected>4.915</expected>
          <tolerance>0.01</tolerance>
          <description>Boundary event total response conserved</description>
        </check>
        
        <check>
          <type>column_sum</type>
          <location>
            <column>3</column>  <!-- precise condition -->
          </location>
          <expected>4.916</expected>
          <tolerance>0.01</tolerance>
          <description>Precise event total response conserved</description>
        </check>
        
        <!-- 7. CAUSALITY PRESERVATION: No response before onset -->
        <check>
          <type>exact_value</type>
          <location>
            <column>2</column>  <!-- precise condition at t=25.123 -->
            <row>12</row>  <!-- At t=24s, before onset -->
          </location>
          <expected>0.0</expected>
          <tolerance>1e-10</tolerance>
          <description>Causality preserved: no response before precise onset</description>
        </check>
        
        <!-- 8. NUMERICAL PRECISION: High-precision onsets should be handled accurately -->
        <check>
          <type>exact_value</type>
          <location>
            <column>2</column>  <!-- precise condition -->
            <row>13</row>  <!-- At t=26s, ~0.9s after onset -->
          </location>
          <expected>0.0</expected>
          <tolerance>0.01</tolerance>
          <description>High-precision onset timing accuracy at t=26s</description>
        </check>
        
        <!-- 9. SYMMETRY PRESERVATION: HRF shape should be preserved across different timings -->
        <check>
          <type>undershoot_ratio</type>
          <location>
            <column>0</column>  <!-- boundary condition -->
          </location>
          <expected>-0.0057</expected>  <!-- Ratio of min to max for canonical HRF -->
          <tolerance>0.001</tolerance>
          <description>HRF undershoot ratio preserved for boundary timing</description>
        </check>
        
        <!-- 10. SCAN BOUNDARY ALIGNMENT: Response should align properly with TR grid -->
        <check>
          <type>exact_value</type>
          <location>
            <column>0</column>  <!-- boundary condition -->
            <row>5</row>  <!-- At t=10s, exactly at scan boundary -->
          </location>
          <expected>0.0306</expected>
          <tolerance>0.001</tolerance>
          <description>Scan boundary timing: onset response at t=10s</description>
        </check>
      </numeric_checks>
    </design_matrix>
  </expected_outputs>
  
  <implementations>
    <R><![CDATA[
library(fmridesign)
library(fmrihrf)

# Create sampling frame
sframe <- sampling_frame(blocklens = 60, TR = 2.0)

# Create event data with various timing patterns
event_data <- data.frame(
  onset = c(10.0, 15.3, 25.123, 29.99),
  condition = factor(c("boundary", "fractional", "precise", "near")),
  block = rep(1, 4)
)

# Create event model with high precision
ev_model <- event_model(
  onset ~ hrf(condition),
  data = event_data,
  block = ~block,
  sampling_frame = sframe,
  precision = 0.1  # High precision for temporal accuracy
)

# Get design matrix
dm <- design_matrix(ev_model)

# Convert to regular matrix for numeric checks
dm_matrix <- as.matrix(dm)

# Also test with medium precision for comparison
ev_model_med <- event_model(
  onset ~ hrf(condition),
  data = event_data,
  block = ~block,
  sampling_frame = sframe,
  precision = 0.5  # Medium precision
)

dm_med <- design_matrix(ev_model_med)
dm_med_matrix <- as.matrix(dm_med)
    ]]></R>
  </implementations>
</golden_test>